<html>
<head>
</head>
<body>
  <div id="resultsdiv"></div>
  <script type="text/javascript" src="cterm.js"></script> 
  <script type="text/javascript" src="parser.js"></script>
  <script type="text/javascript" src="simplify.js"></script>
  
  <script type="text/javascript">
  
    //////////////////////////////////////////////////////////////////
	//
	// Symbolic Math Library for Javascript
	//
	// (c) 2011 James McLellan
	//  
	// Permission granted to redistribute for both commercial and non-commercial purposes, provided
	// copyright information is retained.
	//
	//
  
  
    //////////////////////
    // :TODO:
	//
    // 1. Make sure all term types are getting set correctly
	//    a. Change the unit tests to take CTerm, not string, arguments
	// 2. Recognize numbers
	//    a. Use parseFloat(), which will return NaN if no number is found
	// 3. Recognize (1/A) is equivalent to A^-1
	//    a. Detect (1/TERM)
	//    b. Create an "equivalentExpressions" array of 1 item, place the exponential equation as that item
	// 4. Recognize (1/A^n) is equivalent to A^-n
	//    a. Detect (1/(TERM<sup>n</sup>))
	//    b. Create an "equivalentExpressions" array of 1 item, place the exponential equation as that item
	// 5. Recognize associative property of multiplied terms
	//    a. Create an "equivalentExpressions" array of N!-items (where N is number of terms), each containing one of the possible combinations
	//    b. Create a helper function to search through the combinations and find matches
	// 6. Recognize associative property of added terms
	//    a. Create an "equivalentExpressions" array of N!-items (where N is number of terms), each containing one of the possible combinations
	//    b. Create a helper function to search through the combinations and find matches	
	// 7. Recognize negating terms
	//    a. Create a function "CanEvaluate" that determines if a function can be further decomposed
	//    b. Start at the highest level of organization (level 0)
	//    c. Create a function "Simplify" that will, if possible, simplify the equation one step further
	//       i. For each term, look for a "subtraction" term
	//          (0) If there are no "subtraction" terms, anywhere in the term list, we are done
	//          (1) Look through "equivalentExpressions" to see if this term is the same
	//          (2) If it is, remove both terms
	// 8. Perform basic A^n = nA^(n-1) differential
	//    a. Recognize that there is an A^n equivalent in the "equivalentExpressions" array
	//    b. Capture the exponent seperate from the root
	//    c. Push a multiplier ahead of the root
	//    d. Modify the exponent
	//       i. If the exponent is a number, just decrement
	
    var stringToParse = "&part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - &part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + (0.5&dot;(1/A)&dot;(&part;A/&part;x))&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - (0.5&dot;(1/A)&dot;(&part;A/&part;x))&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + &part;x&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - &part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + (0.5&dot;(1/A)&dot;(0-&part;B/&part;t))&dot;(0.5&dot;(1/B)&dot;(&part;B/&part;t)) - (0.5&dot;(1/A)&dot;(0-&part;B/&part;t))&dot;(0.5&dot;(1/B)&dot;(&part;B/&part;t))";
	
	

	
	function runStuff() 
	{
        //var thisTerm = new CTerm(stringToParse);	
		
		DoTest("A", [new CTerm("A", "none")]);
		DoTest("-A", [new CTerm("A", "none")]);
		
        DoTest("A+B", [new CTerm("A", "addition"), new CTerm("B", "none")]);
		DoTest("A-B", [new CTerm("A", "subtraction"), new CTerm("B", "none")]);

		DoTest("A&dot;B", [new CTerm("A", "multiply"), new CTerm("B", "none")]);
		DoTest("A/B", [new CTerm("A", "divide"), new CTerm("B", "none")]);
		
		DoTest("A&dot;B-A&dot;B", [new CTerm("A", "multiply"), new CTerm("B", "subtraction"), new CTerm("A", "multiply"), new CTerm("B", "none")]);

		DoTest("(A+B)-C+(D+E)",[new CTerm("(A+B)", "subtraction"), new CTerm("C", "addition"), new CTerm("(D+E)", "none")]);
		DoTest("(A&dot;(B+C)-D)+E+(F&dot;((G+1)/H))", [new CTerm("(A&dot;(B+C)-D)", "addition"), new CTerm("E", "addition"), new CTerm("(F&dot;((G+1)/H))", "none")]);
		
		DoTest("A<sup>B</sup>", [new CTerm("A", "exponent"), new CTerm("B", "none")]);
		DoTest("A<sup>-B</sup>", [new CTerm("A", "exponent"), new CTerm("B", "none")]);
		DoTest("A<sup>B</sup>-(C&dot;D)/E", [new CTerm("A", "exponent"), new CTerm("B", "subtraction"), new CTerm("(C&dot;D)", "divide"), new CTerm("E", "none")]);
		DoTest("A<sup>-B</sup>-(C&dot;D)/E", [new CTerm("A", "exponent"), new CTerm("B", "subtraction"), new CTerm("(C&dot;D)", "divide"), new CTerm("E", "none")]);
		
		SimplifyTest(new CTerm("A/A"), [new CTerm("1", "none")]);
		SimplifyTest(new CTerm("B/C&dot;C/B"), [new CTerm("1", "none")]);				
		SimplifyTest(new CTerm("0&dot;B"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("A&dot;B/C&dot;0/B"), [new CTerm("0", "none")]);		
		SimplifyTest(new CTerm("B&dot;A/A"), [new CTerm("B", "none")]);
		SimplifyTest(new CTerm("A&dot;B/A"), [new CTerm("B", "none")]);		
		SimplifyTest(new CTerm("A&dot;A/A"), [new CTerm("A", "none")]);	
		SimplifyTest(new CTerm("1/A"), [new CTerm("1", "divide"), new CTerm("A", "none")]);
		SimplifyTest(new CTerm("C/A"), [new CTerm("C", "divide"), new CTerm("A", "none")]);
		SimplifyTest(new CTerm("A&dot;B/C&dot;C/B"), [new CTerm("A", "none")]);
		
		SimplifyTest(new CTerm("A-A"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("-A+A"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("A+B-A-B"), [new CTerm("0", "none")]);		
		SimplifyTest(new CTerm("A+B-A"), [new CTerm("B", "none")]);
		SimplifyTest(new CTerm("A+B+C-B-A"), [new CTerm("C", "none")]);
		SimplifyTest(new CTerm("A+B-C-B-A"), [new CTerm("C", "none")]);
		
		
		SimplifyTest(new CTerm("A&dot;B-A&dot;B"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("-A&dot;B+A&dot;B"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("A/B-A/B"), [new CTerm("0", "none")]);
		SimplifyTest(new CTerm("-A/B+A/B"), [new CTerm("0", "none")]);		
		
		// :TODO: Need to modify unit test to check for the sign on the resulting numbers
		
		/*
		DoTestDiff("&part;A/&part;x", ["A"], ["x"]);
		DoTestDiff("&part;A/&part;x&part;t", ["A"], ["x", "t"]);
		DoTestDiff("&part;x(0.5&dot;(1/A))", ["(0.5&dot;(1/A))"],["x"]);
		*/
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	function SimplifyTest( termInput, expectedResults )
	{
		var testString = termInput.unevaluatedString;	
	    alert("Running test " + testString );
		termInput.Evaluate(termInput.unevaluatedString);
		var resultTerm = new CTerm("");
		resultTerm.terms = SimplifyTerms(termInput);
		//resultTerm = termInput.Simplify(termInput);
		//alert("Simplify returned " + resultTerm.terms.length + " term, value = " + resultTerm.terms[0].unevaluatedString );
		checkUnitTest(testString, resultTerm, expectedResults);	
		alert("Completed test " + testString );	
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	function DoTest(testString, expectedResults)
	{
	    alert("Running test " + testString );
		var thisTerm = new CTerm(testString);
		thisTerm.Evaluate(testString);
		checkUnitTest(testString, thisTerm, expectedResults);	
		alert("Completed test " + testString );
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
    function DoTestDiff(testString, expectedResults, expectedDiffs)
	{
	    alert("Running test " + testString );
		var thisTerm = new CTerm(testString);
		thisTerm.Evaluate(testString);
		checkUnitTestDiff(testString, thisTerm, 0, expectedResults, expectedDiffs);	
		alert("Completed test " + testString );
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	function checkUnitTest( testname, term, expectedResults )
	{
	   if(term.terms.length != expectedResults.length)
	   {
	      alert("Test '" + testname + "': Number of terms isn't correct. Expect " + expectedResults.length + ", observed " + term.terms.length);
	   }
	   for (var i = 0; i < expectedResults.length; i++)
	   {
	      // check term value
	      if (term.terms[i].unevaluatedString != expectedResults[i].unevaluatedString)
		  {
		     alert( "TEST Name: '" + testname + "' term " + (i) + ". Expected '" + expectedResults[i].unevaluatedString + "', observed '" + term.terms[i].unevaluatedString + "'"); 
		  }
		  // check relationship type
	      if (term.terms[i].relationshipToNextTerm != expectedResults[i].relationshipToNextTerm)
		  {
		     alert( "TEST Type: '" + testname + "' term " + (i) + ". Expected '" + expectedResults[i].relationshipToNextTerm + "', observed '" + term.terms[i].relationshipToNextTerm + "'"); 
		  }		  
		  // check partial differentials
		  // :TODO:
	   }
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	
	function checkUnitTestDiff( testname, term, index, expectedResults, expectedDiffs )
	{
	   if(term.terms.length != expectedResults.length)
	   {
	      alert("Test '" + testname + "': Number of terms isn't correct. Expect " + expectedResults.length + ", observed " + term.terms.length);
		  
		  for (var k = 0; k < term.terms.length; k++)
		  {
		     alert("Term " + k + " = " + term.terms[k].unevaluatedString);
		  }
	   }
//	   for (var i = 0; i < expectedResults.length; i++)
//	   {
       var i = index;
	      if (term.terms[i].unevaluatedString != expectedResults[0])
		  {
		     alert( "TEST: '" + testname + "' term " + (i) + ". Expected '" + expectedResults[0] + "', observed '" + term.terms[i].unevaluatedString + "'"); 
		  }
//	   }
	   
	   for (var j = 0; j < expectedDiffs.length; j++)
	   {
	      if (term.terms[i].withRespectTo[j] != expectedDiffs[j])
		  {
		     alert( "TEST: '" + testname + "' term " + (i) + ". Expected '" + expectedDiffs[j] + "', observed '" + term.terms[i].withRespectTo[j] + "'"); 
		  }		  
	   }
	}	
	

	
	////////////////////////////////////////////////////////////////////////////////////
	
	
  </script>
  <input type="button" value="Simplify Equations" onclick="runStuff()" />
</body>
</html>