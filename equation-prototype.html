<html>
<head>
</head>
<body>
  <div id="resultsdiv"></div>
  <script type="text/javascript">
  
    var stringToParse = "&part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - &part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + (0.5&dot;(1/A)&dot;(&part;A/&part;x))&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - (0.5&dot;(1/A)&dot;(&part;A/&part;x))&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + &part;x&dot;(0.5&dot;(1/A)&dot;(&part;A/&part;x)) - &part;x(0.5&dot;(1/A)&dot;(&part;A/&part;x)) + (0.5&dot;(1/A)&dot;(0-&part;B/&part;t))&dot;(0.5&dot;(1/B)&dot;(&part;B/&part;t)) - (0.5&dot;(1/A)&dot;(0-&part;B/&part;t))&dot;(0.5&dot;(1/B)&dot;(&part;B/&part;t))";
 
    function CTerm(termString)
	{
	   //alert("Creating term " + termString);
	   this.relationToPreviousTerm = "";
	   this.relationToNextTerm = "";
	   this.operation = "";
	   this.withRespectTo = new Array();
	   this.terms = new Array();
	   //this.terms[0] = []; // the 0-row of the terms array is the current (unexpanded) level
	   this.Evaluate = Parse;
	   this.unevaluatedString = termString;
	   //this.Evaluate(termString);
	}
	
	function runStuff() 
	{
        //var thisTerm = new CTerm(stringToParse);	
		
        DoTest("A+B", ["A", "B"]);
		DoTest("A-B", ["A", "B"]);
		
		DoTest("A&dot;B", ["A", "B"]);
		DoTest("A/B", ["A", "B"]);
		
		DoTest("(A+B)-C+(D+E)",["(A+B)", "C", "(D+E)"]);
		DoTest("(A&dot;(B+C)-D)+E+(F&dot;((G+1)/H))", ["(A&dot;(B+C)-D)", "E", "(F&dot;((G+1)/H))"]);
		
		DoTestDiff("&part;A/&part;x", ["A"], ["x"]);
		DoTestDiff("&part;A/&part;x&part;t", ["A"], ["x", "t"]);
		DoTestDiff("&part;x(0.5&dot;(1/A))", ["(0.5&dot;(1/A))"],["x"]);
	}
	
	function DoTest(testString, expectedResults)
	{
	    alert("Running test " + testString );
		var thisTerm = new CTerm(testString);
		thisTerm.Evaluate(testString);
		checkUnitTest(testString, thisTerm, expectedResults);	
		alert("Completed test " + testString );
	}
	
    function DoTestDiff(testString, expectedResults, expectedDiffs)
	{
	    alert("Running test " + testString );
		var thisTerm = new CTerm(testString);
		thisTerm.Evaluate(testString);
		checkUnitTestDiff(testString, thisTerm, 0, expectedResults, expectedDiffs);	
		alert("Completed test " + testString );
	}
	
	function checkUnitTest( testname, term, expectedResults )
	{
	   if(term.terms.length != expectedResults.length)
	   {
	      alert("Test '" + testname + "': Number of terms isn't correct. Expect " + expectedResults.length + ", observed " + term.terms.length);
	   }
	   for (var i = 0; i < expectedResults.length; i++)
	   {
	      if (term.terms[i].unevaluatedString != expectedResults[i])
		  {
		     alert( "TEST: '" + testname + "' term " + (i) + ". Expected '" + expectedResults[i] + "', observed '" + term.terms[i].unevaluatedString + "'"); 
		  }
	   }
	}
	
	function checkUnitTestDiff( testname, term, index, expectedResults, expectedDiffs )
	{
	   if(term.terms.length != expectedResults.length)
	   {
	      alert("Test '" + testname + "': Number of terms isn't correct. Expect " + expectedResults.length + ", observed " + term.terms.length);
		  
		  for (var k = 0; k < term.terms.length; k++)
		  {
		     alert("Term " + k + " = " + term.terms[k].unevaluatedString);
		  }
	   }
//	   for (var i = 0; i < expectedResults.length; i++)
//	   {
       var i = index;
	      if (term.terms[i].unevaluatedString != expectedResults[0])
		  {
		     alert( "TEST: '" + testname + "' term " + (i) + ". Expected '" + expectedResults[0] + "', observed '" + term.terms[i].unevaluatedString + "'"); 
		  }
//	   }
	   
	   for (var j = 0; j < expectedDiffs.length; j++)
	   {
	      if (term.terms[i].withRespectTo[j] != expectedDiffs[j])
		  {
		     alert( "TEST: '" + testname + "' term " + (i) + ". Expected '" + expectedDiffs[j] + "', observed '" + term.terms[i].withRespectTo[j] + "'"); 
		  }		  
	   }
	}	
	
    function Parse(stringIn)
	{
	    var newStart = 0;
		
		//alert("I have arrived for string " + stringIn);
	    for (var i = 0; i < stringIn.length; i++)
		{
		    //alert("Looking at char " + stringIn.charAt(i));
			
		    // Look for paren on this character
			if (IsParen(stringIn, i))
			{
			   //alert("IsParen");
			   // a. find the end of this paren group
			   var endOfParen = identifyNestedParen(stringIn, i);
			   // b. push the paren group onto the terms array
			   var subTerm = stringIn.substring(i+1, endOfParen + i);
			   //alert("Full paren found " + subTerm);
			   //var tempTerm = new CTerm(subTerm);
			   //this.terms.push(tempTerm);
			   // c. skip i to the end of the paren group
			   i = i + endOfParen;
			   //newStart = i;
			   //alert("End of parent reached. Next character = '" + stringIn.charAt(i) + "'");
			}
			
			// Look for addition or subtraction
			if (IsAddSubtract(stringIn, i))
			{
			   //alert("IsAddSub");
			   // a. push the previous term onto the terms arry
			   //    i. set the previous term's "relationshipToNextTerm" to "addition" or "subtraction"
			   var lastEntry = 0;
			   if (this.terms.length != null)
			   {
			      lastEntry = this.terms.length;
			   }
			   var type = DetermineAddSubType(stringIn, i);
			   //    ii. set the next term's "relationshipToPreviousTerm" to "addition" or "subtraction"
			   var subTerm = stringIn.substring(newStart, i );
			   var tempTerm = new CTerm(subTerm);
			   tempTerm.relationshipToNextTerm = type;
			   this.terms.push(tempTerm);
			   //    iii. do not get the next term
			   //    iv. skip i to where the + or - was found
			   newStart = i + 1;
			}
			
			// Look for a partial differential
			if (IsDiff(stringIn, i))
			{
			    //alert("IsDiff of/wrt " + stringIn.charAt(i+6));
			    // a. look for the next term
				//   i. if the next term is a letter, add that letter to the "withRespectTo" array
				if (IsLetter(stringIn, i+6))
				{
				    //alert("Diff argument found");
					//      1. look to see if there is a paren next
					if (IsParen(stringIn, i+7))
					{
						//            (a) if there is, grab the whole term and push it onto the terms array				   
					    var endOfParen = identifyNestedParen(stringIn, i+7);
			            // b. push the paren group onto the terms array
			            var subTerm = stringIn.substring(i+7+1, endOfParen + i+7);
			            var tempTerm = new CTerm(subTerm);
						tempTerm.withRespectTo.push(stringIn.charAt(i+6));
			            this.terms.push(tempTerm);
						newStart = i + 7 + endOfParen;
						i = newStart;
					}
					
					//      2. look to see if there is a division sybol next
					if (IsDiv(stringIn, i+7))
					{
						//            (b) if there is, look to see if there's a partial differential term next
						var k = 0;
						var tempTerm = new CTerm(stringIn.charAt(i+6));							
						while (IsDiff(stringIn, i+8+k))
						{
							//                (i) look for multiple partial differentials; push each one onto the "withRespectTo" array
							tempTerm.withRespectTo.push(stringIn.charAt(i+8+k+6));
							k = k+7;
							newStart = i+8+k;
							i = newStart;
						}
						this.terms.push(tempTerm);
					}
					newStart = i+7;
					i = newStart;
				}
			}
			
			// Look for an exponent
			if (IsExponent(stringIn, i))
			{
			   //alert("IsExp");
			   // a. get the whole exponent
			   // b. evaluate whatever was immediately to the right of this and push it onto the terms array
			   //    i. set the term's "relationshipToNextTerm" to "root"
			   // c. push the whole exponent onto the terms array
			   //    i. set the term's "relationshipToPreviousTerm" to "exponent"
			   // d. skip i to the end of this block
			}
			
			// Look for multiplication or division
			if (IsMultiplicationDivision(stringIn, i))
			{
			   //alert("IsMult");
			   // a. push the previous term onto the terms arry
			   //    i. set the previous term's "relationshipToNextTerm" to "multiplication" or "division"
			   var lastEntry = 0;
			   if (this.terms.length != null)
			   {
			      lastEntry = this.terms.length;
			   }
			   var type = DetermineMulDivType(stringIn, i);
			   //    ii. set the next term's "relationshipToPreviousTerm" to "multiplication" or "division"
			   var subTerm = stringIn.substring(newStart, i );
			   var tempTerm = new CTerm(subTerm);
			   tempTerm.relationshipToNextTerm = type;
			   this.terms.push(tempTerm);
			   //    iii. do not get the next term
			   //    iv. skip i to where the * or / was found
			   if (type == "multiply") 
			   {
			      newStart = i + 5;
				  i = newStart;
			   }
			   else
			   {
			      newStart = i + 1;
			   }
			}
			
			// Look for a trig function
			if (IsTrigFunction(stringIn, i))
			{
			   // do nothing yet
			}
		}
		// at the end of the process, take any trailing data without operators and push as a term
	    var subTerm = stringIn.substring(newStart, i );
		//alert("End of String. Last term start " + newStart + ", end " + i + ". Value = " + subTerm);
		if (subTerm != "") {
	       var tempTerm = new CTerm(subTerm);
	       tempTerm.relationshipToNextTerm = "none";
	       this.terms.push(tempTerm);
		}
	}
	
	function IsLetter(stringIn, i)
	{
	   var testChar = stringIn.charAt(i);
	   if (testChar.match(/[a-zA-Z]/) != null)
	   {
	      return true;
	   } 
	   else
	   {
	      return false;
	   }
	}
	
	function IsTrigFunction(stringIn, i)
	{
	   return false;
	}

	function DetermineMulDivType(stringIn, i)
	{
	   if ((stringIn.charAt(i) == "&") && 
	      (stringIn.charAt(i+1) == "d") &&
		  (stringIn.charAt(i+2) == "o") &&
		  (stringIn.charAt(i+3) == "t") &&
		  (stringIn.charAt(i+4) == ";") )
        {
		   return "multiply";
        }		
		if (stringIn.charAt(i) == "/")
		{
		  return "divide";
		}
		return false;
	}
	
	function IsMultiplicationDivision(stringIn, i)
	{
	   //alert("Checking for mult/div, starting char = " + stringIn.charAt(i));
	   if ((stringIn.charAt(i) == "&") && 
	      (stringIn.charAt(i+1) == "d") &&
		  (stringIn.charAt(i+2) == "o") &&
		  (stringIn.charAt(i+3) == "t") &&
		  (stringIn.charAt(i+4) == ";") )
        {
		   return true;
        }		
		if (stringIn.charAt(i) == "/")
		{
		  return true;
		}
		return false;
	}

	function DetermineAddSubType(stringIn, i)
	{
	   if (stringIn.charAt(i) == "+") 
	   {
	      return("addition");
	   }
	   
	   if (stringIn.charAt(i) == "-")
	   {
		   return("subtraction");
	   }
	}
	
	function IsAddSubtract(stringIn, i)
	{
	   if ((stringIn.charAt(i) == "+") ||
	       (stringIn.charAt(i) == "-") )
		{
		   return true;
		}
		else
		{
		   return false;
		}
	}
	
	function IsExponent(stringIn, i)
	{
	   if ((stringIn.charAt(i) == "<") && 
	      (stringIn.charAt(i+1) == "s") &&
		  (stringIn.charAt(i+2) == "u") &&
		  (stringIn.charAt(i+3) == "p") &&
		  (stringIn.charAt(i+3) == ">") )
	   {
	      return true;
	   }
	   else
	   {
	      return false;
	   }	
	}
	
	function IsDiff(stringIn, i)
	{
	   if (stringIn.charAt(i) == "&" && 
	      (stringIn.charAt(i+1) == "p") &&
		  (stringIn.charAt(i+2) == "a") &&
		  (stringIn.charAt(i+3) == "r") &&
		  (stringIn.charAt(i+4) == "t") &&
		  (stringIn.charAt(i+5) == ";") )
	   {
	      return true;
	   }
	   else
	   {
	      return false;
	   }
	}
	
	function IsDiv(stringIn, i)
	{
	   if (stringIn.charAt(i) == "/")
	   {
	      return true;
	   }
	   else
	   {
	      return false;
	   }
	}	
	
	function IsParen(stringIn, i)
	{
	   if (stringIn.charAt(i) == "(")
	   {
	      return true;
	   }
	   else
	   {
	      return false;
	   }
	}
 
    function identifyNestedParen(stringIn, i)
    {
	   // stringIn should be a token that begins with the paren; 
	   //  this will count open and closing pares until zero is reached and return the substring begining and end for slicing
	   var parenCount = 0;
	   var j = 0; // loop counter
	   for (j = 0; j < (stringIn.length - i); j++)
	   {
	      if (stringIn.charAt(i + j) == '(')
		  {
		     parenCount++;
		  } 
		  if (stringIn.charAt(i + j) == ')')
		  {
		     parenCount--;
		  }
		  if (parenCount == 0)
		  {
		     break;
		  }
	   }
	   return(j);
    }	
	
	function Term()
	{
	   this.thisTerm = "";
	   this.relationshipToNextTerm = "";
	   this.relationshipToPreviousTerm = "";
	   this.withRespectTo = [];
	}
  </script>
  <input type="button" value="Do It" onclick="runStuff()" />
</body>
</html>